start
  = r:rule { return r; }

rule
  = r:binary_rule
  / r:unary_rule {
    return r;
  }

predicate
  = p:("exist") {
    return p;
  }

unary_rule
  = p:predicate space s0:selector {
    return {
      type: 'unary_rule',
      predicate: p,
      selector: s0
    }
  }

binary_rule
  = s0:selector space r:relation space s1:selector {
    return {
      type: 'binary_rule',
      selector0: s0,
      relation: r,
      selector1: s1
    }
  }

selector
  = l:literal {
    return {
      type: 'plain_selector',
      value: l
    };
  }

literal
  = str:[a-zA-Z0-9\.#]+ {
    return str.join('');
  }

relation
  = r:has_child_relation { return r; }
  / r:has_parent_relation { return r; }

has_child_relation
 = "->" {
   return {
     type: 'relation',
     subtype: 'has_child_relation'
   };
 }

has_parent_relation
 = "<-" {
   return {
     type: 'relation',
     subtype: 'has_parent_relation'
   };
 }

space
  = chars:[ \t]+ {
    return "SPACE"
  }
